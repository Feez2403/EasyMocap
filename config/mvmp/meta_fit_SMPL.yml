init_params: # Initialization Stance
  module: myeasymocap.operations.init.InitParams
  key_from_data: [keypoints3d]
  args:
    num_poses: 69
    num_shapes: 10
fitShape: #  This step requires a bit of optimization of the shape parameter of SMPL based on the length of the bone
  module: myeasymocap.operations.optimizer.Optimizer
  key_from_data: [keypoints3d]
  key_from_previous: [model, params] # The model used for this step of the optimization is a callable function that is responsible for turning the inputs of params into outputs without having to think about anything else, which is not the same as the SMPL model
  args:
    optimizer_args: {optim_type: lbfgs}
    optimize_keys: [shapes]
    loss:
      k3d:
        weight: 1000.
        module: myeasymocap.operations.loss.LimbLength
        key_from_output: [keypoints]
        key_from_infos: [keypoints3d]
        args:
          kintree: [[8, 1], [2, 5], [2, 3], [5, 6], [3, 4], [6, 7], [2, 3], [5, 6], [3, 4], [6, 7], [2, 3], [5, 6], [3, 4], [6, 7], [1, 0], [9, 12], [9, 10], [10, 11], [12, 13],[13, 14]]
      regshape:
        weight: 0.1
        module: myeasymocap.operations.loss.RegLoss
        key_from_output: [shapes]
        key_from_infos: [] # TODO: Calculate the smooth weights based on the confidence level of 2D
        args:
          key: shapes
          norm: l2
init_RT: # In this step, the shape parameter of the SMPL parameter is first averaged over the whole segment. Re-optimize to update the RT parameters
  module: myeasymocap.operations.optimizer.Optimizer
  key_from_data: [keypoints3d]
  key_from_previous: [model, params] # The model used for this step of the optimization is a callable function that is responsible for turning the inputs of params into outputs without having to think about anything else, which is not the same as the SMPL model
  # This is designed so that for some models that are more than just SMPL itself, a layer of interfaces can be applied on the outside
  # model is a pure function to visualize the results
  args:
    optimizer_args: {optim_type: lbfgs}
    optimize_keys: [Th, Rh]
    loss:
      k3d:
        weight: 100.
        module: myeasymocap.operations.loss.Keypoints3D
        key_from_output: [keypoints]
        key_from_infos: [keypoints3d]
        args:
          norm: l2
          index_est: [2, 5, 9, 12]
          index_gt: [2, 5, 9, 12]
      smooth:
        weight: 1.
        module: myeasymocap.operations.loss.Smooth
        key_from_output: [Th, keypoints]
        key_from_infos: [] # TODO: Calculate the smooth weights based on the 2D confidence level
        args:
          keys: [keypoints, Th]
          smooth_type: [Linear, Linear] # This depth seems to require the camera parameters to be converted
          norm: [l2, l2]
          order: [2, 2]
          weights: [10., 100.]
          window_weight: [0.5, 0.3, 0.1, 0.1]
refine_poses:
  repeat: 2
  module: myeasymocap.operations.optimizer.Optimizer
  key_from_data: [keypoints3d]
  key_from_previous: [model, params]
  args:
    optimizer_args: {optim_type: lbfgs}
    optimize_keys: [[poses, Rh, Th], [poses, shapes, Rh, Th]]
    loss:
      k3d:
        weight: 1000.
        module: myeasymocap.operations.loss.Keypoints3D
        key_from_output: [keypoints]
        key_from_infos: [keypoints3d]
        args:
          norm: l2
          norm_info: 0.02
          ranges_est: [0, 25]
          ranges_gt: [0, 25]
      smooth:
        weight: 1.
        module: myeasymocap.operations.loss.Smooth
        key_from_output: [poses, Th, keypoints]
        key_from_infos: [] # TODO: Calculate the smooth weights based on the 2D confidence level
        args:
          keys: [Th, poses, keypoints]
          smooth_type: [Linear, Linear, Linear] # This depth seems to require the camera parameters to be converted
          norm: [l2, l2, l2]
          order: [2, 2, 2]
          weights: [10., 10., 10.,]
          window_weight: [0.5, 0.3, 0.1, 0.1]
      prior:
        weight: 0.1
        module: easymocap.multistage.gmm.GMMPrior
        key_from_output: [poses]
        key_from_infos: []
        args:
          start: 0
          end: 69
      regshape:
        weight: 0.1
        module: myeasymocap.operations.loss.RegLoss
        key_from_output: [shapes]
        key_from_infos: [] # TODO: Calculate the smooth weights based on the 2D confidence level
        args:
          key: shapes
          norm: l2