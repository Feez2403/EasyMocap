init_params: # Initialize posture
  module: myeasymocap.operations.init.InitParams
  key_from_data: [keypoints3d]
  args:
    num_poses: 69
    num_shapes: 10
fitShape: # This step requires optimizing the SMPL shape parameters based on bone length.
  module: myeasymocap.operations.optimizer.Optimizer
  key_from_data: [keypoints3d]
  key_from_previous: [model, params] #The model used in this step of optimization is a callable function that is responsible for turning the input of params into output without considering other things. It is different from the SMPL model.
  args:
    optimizer_args: {optim_type: lbfgs}
    optimize_keys: [shapes]
    loss:
      k3d:
        weight: 1000.
        module: myeasymocap.operations.loss.LimbLength
        key_from_output: [keypoints]
        key_from_infos: [keypoints3d]
        args:
          kintree: [[8, 1], [2, 5], [2, 3], [5, 6], [3, 4], [6, 7], [2, 3], [5, 6], [3, 4], [6, 7], [2, 3], [5, 6], [3, 4], [6, 7], [1, 0], [9, 12], [9, 10], [10, 11], [12, 13],[13, 14]]
      regshape:
        weight: 0.1
        module: myeasymocap.operations.loss.RegLoss
        key_from_output: [shapes]
        key_from_infos: [] # TODO: Calculate smooth weight based on 2D confidence
        args:
          key: shapes
          norm: l2
init_RT: # In this step, the shape parameters of the SMPL parameters are first averaged over the entire section. Re-optimize and update RT parameters
  module: myeasymocap.operations.optimizer.Optimizer
  key_from_data: [keypoints3d]
  key_from_previous: [model, params] # The model used in this step of optimization is a callable function that is responsible for turning the input of params into output without considering other things. It is different from the SMPL model.
  # The purpose of this design is to add a layer of interfaces to some models that are not just SMPL itself.
  # model is a pure function used for visualization
  args:
    optimizer_args: {optim_type: lbfgs}
    optimize_keys: [Th, Rh]
    loss:
      k3d:
        weight: 100.
        module: myeasymocap.operations.loss.Keypoints3D
        key_from_output: [keypoints]
        key_from_infos: [keypoints3d]
        args:
          norm: l2
          index_est: [2, 5, 9, 12]
          index_gt: [2, 5, 9, 12]
      smooth:
        weight: 1.
        module: myeasymocap.operations.loss.Smooth
        key_from_output: [Th, keypoints]
        key_from_infos: [] # TODO: Calculate smooth weight based on 2D confidence
        args:
          keys: [keypoints, Th]
          smooth_type: [Linear, Linear] # This depth seems to require the camera parameters to be converted
          norm: [l2, l2]
          order: [2, 2]
          weights: [10., 100.]
          window_weight: [0.5, 0.3, 0.1, 0.1]
refine_poses:
  repeat: 2
  module: myeasymocap.operations.optimizer.Optimizer
  key_from_data: [keypoints3d]
  key_from_previous: [model, params]
  args:
    optimizer_args: {optim_type: lbfgs}
    optimize_keys: [[poses, Rh, Th], [poses, shapes, Rh, Th]]
    loss:
      k3d:
        weight: 1000.
        module: myeasymocap.operations.loss.Keypoints3D
        key_from_output: [keypoints]
        key_from_infos: [keypoints3d]
        args:
          norm: l2
          norm_info: 0.02
          ranges_est: [0, 25]
          ranges_gt: [0, 25]
      smooth:
        weight: 1.
        module: myeasymocap.operations.loss.Smooth
        key_from_output: [poses, Th, keypoints]
        key_from_infos: [] # TODO: Calculate the smooth weights based on the confidence level of 2D
        args:
          keys: [Th, poses, keypoints]
          smooth_type: [Linear, Linear, Linear] # This depth seems to require the camera parameters to be converted
          norm: [l2, l2, l2]
          order: [2, 2, 2]
          weights: [10., 10., 10.,]
          window_weight: [0.5, 0.3, 0.1, 0.1]
      prior:
        weight: 0.1
        module: easymocap.multistage.gmm.GMMPrior
        key_from_output: [poses]
        key_from_infos: []
        args:
          start: 0
          end: 69
      regshape:
        weight: 0.1
        module: myeasymocap.operations.loss.RegLoss
        key_from_output: [shapes]
        key_from_infos: [] # TODO: Calculate the smooth weights based on the confidence level of 2D
        args:
          key: shapes
          norm: l2